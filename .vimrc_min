set nocompatible
filetype indent on

if !has('g:syntax_on')
  syntax enable
endif

set autoindent
set autoread
set autowriteall
set backspace=indent,eol,start
set breakindent
set conceallevel=0
set cursorline
set expandtab
set hidden
set hlsearch
set ignorecase
set incsearch
set laststatus=2
set lazyredraw
set linespace=2
set magic
set mouse=a
set nobackup
set nofoldenable
set nostartofline
set noswapfile
set nowritebackup
set number
set pastetoggle=<F2>
set relativenumber
set scrolloff=7
set shiftwidth=2
set showmatch
set smartcase
set softtabstop=2
set splitbelow
set splitright
set updatetime=750
set virtualedit=block
set wildignore=*.o,*.obj,*.bak,*.exe,*.py[co],*.swp,*~,*.pyc,.svn
set wildignorecase
set wildmenu
set wildmode=full
let &showbreak = '└ '

if has('nvim')
  set inccommand=split

  tnoremap <c-h> <c-\><c-n><C-w>h
  tnoremap <c-j> <c-\><c-n><C-w>j
  tnoremap <c-k> <c-\><c-n><C-w>k
  tnoremap <c-l> <c-\><c-n><C-w>l
  tnoremap jj    <c-\><c-n>
else
  " Mouse support
  set ttymouse=xterm2
endif

" CUSTOM KEYBINDINGS
" Vim specific
inoremap jj <Esc>
let mapleader = "\<Space>"
nnoremap <space> <nop>
xnoremap <space> <nop>

" Some expansions
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<cr>
inoremap ,, <c-o>A,
inoremap ;; <c-o>A;
inoremap ,M ->
inoremap ,m <c-o>A-><c-f>
inoremap ,n =>
inoremap (<cr> (<cr>)<esc>O
inoremap [<cr> [<cr>]<esc>O
inoremap {<cr> {<cr>}<esc>O

" QOL remappings
cnoremap <c-a> <c-b>
cnoremap <c-k> <up>
cnoremap <c-j> <down>
inoremap <c-a> <home>
inoremap <c-e> <end>
inoremap <m-O> <esc>O
inoremap <m-o> <esc>o
nnoremap <c-down> ]c
nnoremap <c-up>   [c
nnoremap <expr> j v:count ? 'j' : 'gj'
nnoremap <expr> k v:count ? 'k' : 'gk'
nnoremap <leader>n :e <C-R>=fnameescape(expand('%:h')).'/'<cr>
nnoremap <m-O> mzO<esc>`z
nnoremap <m-o> mzo<esc>`z
nnoremap Ø     mzO<esc>`z
nnoremap ø     mzo<esc>`z
nnoremap <silent> <down>  :cnext<cr>
nnoremap <silent> <up>    :cprevious<cr>
nnoremap <silent> <right> :lnext<cr>
nnoremap <silent> <left>  :lprevious<cr>
nnoremap <silent> <leader>= <c-w>=
nnoremap <silent> <leader>X :qa!<cr>
nnoremap <silent> <leader>\| <c-w>\|
nnoremap <silent> <leader>_ <c-w>_
nnoremap <silent> <leader>c :close<cr>
nnoremap <silent> <leader>P :set wrap!<cr>
nnoremap <silent> <leader>q :%bdelete<cr>
nnoremap <silent> <leader>w :w!<cr>
nnoremap <silent> <leader>x :qa<cr>
nnoremap <silent> <leader>ª :bp!\|bd! #<cr>
nnoremap <silent> <leader>º :bp\|bd #<cr>
nnoremap <silent> <leader>Ç :lclose<cr>
nnoremap <silent> <leader>ç :lwindow<cr>
nnoremap <silent> g2 :set shiftwidth=2 softtabstop=2 expandtab \| retab<cr>gg=G
nnoremap <silent> g4 :set shiftwidth=4 softtabstop=4 expandtab \| retab<cr>gg=G
nnoremap <silent> ª :bdelete!<cr>
nnoremap <silent> º :bdelete<cr>
nnoremap <silent> Ç :cclose<cr>
nnoremap <silent> ç :cwindow<cr>
nnoremap M <c-w>o
nnoremap Q @q
nnoremap Y y$
nnoremap Ñ ?
nnoremap ñ /
noremap ' `
noremap <silent> <leader>, :set relativenumber! cursorline!<cr>
noremap <silent> <leader>; :set number! relativenumber! cursorline!<cr>
noremap <silent> <leader><cr> :noh<cr>
noremap H g^
noremap L g$
onoremap ar a]
onoremap ir i]
xnoremap <silent> Q :norm @q<cr>

" Properly indent text when pasting
nnoremap p p`[v`]=
nnoremap P P`[v`]=
nnoremap gp p
nnoremap gP P

" Repeat command in last tmux split. "-t !" refers to last pane
nnoremap <silent> <leader>i :silent !tmux send-keys -t \! Up Enter<cr>:redraw!<cr>

" Execute current line in last tmux split
nnoremap <silent> <leader>I :silent exec '!tmux send-keys -t \! ' . shellescape(getline('.')) . ' Enter'<cr>:redraw!<cr>

" Select last inserted text
nnoremap gV `[v`]

" Change word under cursor or selection with yanked
nnoremap R ciw<c-r>0<esc>
xnoremap R "0p

" Repeat command on each line of visual selection
xnoremap <silent> . :normal .<cr>

" Maintain Visual Mode after shifting > and <
xnoremap < <gv
xnoremap > >gv

" Don't jump to the next ocurrence with * and #
nnoremap * :silent keepjumps normal! mi*`i<CR>
nnoremap # :silent keepjumps normal! mi#`i<CR>

" If I have a visual selection and press * I want it to show ocurrences
xnoremap * ymi/<c-r>"<cr>`i
xnoremap # y?<c-r>"<cr>

" Save with root permissions
command! W w !sudo tee % > /dev/null

" Open file explorer
nnoremap <silent> <leader>k :Lexplore<cr>
nnoremap <silent> - :Vexplore<cr>

" Quick replace word under cursor
nnoremap s  :%s///g<left><left><left>
nnoremap S  :%s/\<<c-r><c-w>\>//g<left><left>
xnoremap s  :%s///g<left><left><left>
xnoremap S y:%s/<c-r>"//g<left><left>

" Copy to clipboard
nnoremap <leader>y "+y
nnoremap <leader>Y "+y$
xnoremap <leader>y "+y
nnoremap <leader>d "+d
nnoremap <leader>D "+D
xnoremap <leader>d "+d

" Move a line of text using alt+[jk]
nnoremap <silent> <M-j> :m+<cr>==
nnoremap <silent> <M-k> :m-2<cr>==
xnoremap <silent> <M-j> :m'>+<cr>`<my`>mzgv=gv`yo`z
xnoremap <silent> <M-k> :m'<-2<cr>`>my`<mzgv=gv`yo`z
nnoremap <silent> ¶ :m+<cr>==
nnoremap <silent> § :m-2<cr>==
xnoremap <silent> ¶ :m'>+<cr>`<my`>mzgv=gv`yo`z
xnoremap <silent> § :m'<-2<cr>`>my`<mzgv=gv`yo`z

" Navigate buffers
nnoremap <BS> <C-^>
nnoremap <leader><leader> :ls<cr>:b!<space>
nnoremap <leader>m :marks<cr>
nnoremap <silent> <leader>t :enew<cr>
nnoremap <silent> <s-tab> :bprevious<cr>
nnoremap <silent> <tab> :bnext<cr>

" Remapping <tab> makes <c-i> not work
nnoremap <c-e> <c-i>

" Tags
nnoremap t <C-]>
nnoremap T g]
nnoremap <silent> gt :vsp <cr><c-]>
nnoremap <silent> gT :sp <cr><c-]>
nnoremap <silent> <leader>T :VimProcBang ctags<cr>

" Work with splits
nnoremap <leader>v <c-w>v<c-w>l
nnoremap <leader>h <c-w>s<c-w>j

" sort operator and mappings
function! SortLinesOpFunc(...)
  '[,']sort
endfunction

function! SortReverseLinesOpFunc(...)
  '[,']sort!
endfunction

nnoremap <silent> gs :<C-U>set operatorfunc=SortLinesOpFunc<CR>g@
xnoremap <silent> gs :sort<cr>
nnoremap <silent> gr :<C-U>set operatorfunc=SortReverseLinesOpFunc<CR>g@
xnoremap <silent> gr :sort!<cr>

" Smooth Grepping
command! -nargs=+ -complete=file Grep silent! grep! -R <args>|cwindow|redraw!
nnoremap <leader>f  :Grep ""<left>
xnoremap <leader>f y:Grep "<c-r>""
nnoremap K  :silent Grep "\b<cword>\b"<cr>
xnoremap K y:silent Grep "<c-r>""<cr>

" The Silver Searcher
if executable('ag')
  " Use ag over grep
  set grepprg=ag\ --vimgrep\ --smart-case
  set grepformat=%f:%l:%c:%m
endif

" Use rg over Grep
if executable('rg')
  set grepprg=ag\ --vimgrep\ --smart-case
  set grepformat=%f:%l:%c:%m
endif

" Fast vimrc editing
nnoremap <silent> <leader>ee :e! $MYVIMRC<cr>
nnoremap <silent> <leader>ev :vs $MYVIMRC<cr>
nnoremap <silent> <leader>eh :sp $MYVIMRC<cr>
nnoremap <silent> <leader>es :so $MYVIMRC<cr>

" Duplicate file
nnoremap <leader>W :saveas <C-R>=fnameescape(expand('%:h')).'/'<cr>

" Toggle spell check
nnoremap <leader>A :setlocal spell! spelllang=en_us<cr>

" Scratch buffer
command! ScratchBuffer enew | setlocal buftype=nofile bufhidden=hide noswapfile
nnoremap <silent> <leader>J :ScratchBuffer<cr>

" Sessions
nnoremap <c-s> :mksession! ~/.vim/sessions/
nnoremap <c-p> :source ~/.vim/sessions/

" Make
nnoremap <leader>! :!
nnoremap m<cr>     :make<cr>
nnoremap m<space>  :make<space>

" Commands
augroup vimrc
  autocmd!

  " Autosave on focus lost
  autocmd FocusLost * silent! wa

  " Remove whitespace on save
  autocmd BufWritePre * :%s/\s\+$//e

  " Fold method='indent' + manual folding (with zo and zc)
  au BufReadPre * setlocal foldmethod=indent
  au BufWinEnter * if &fdm == 'indent' | setlocal foldmethod=manual | endif

  " Return to last edit position when opening files (You want this!)
  autocmd BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif
augroup end

" Hex mode
" ex command for toggling hex mode - define mapping if desired
command! -bar Hexmode call ToggleHex()

" helper function to toggle hex mode
function! ToggleHex()
  " hex mode should be considered a read-only operation
  " save values for modified and read-only for restoration later,
  " and clear the read-only flag for now
  let l:modified=&mod
  let l:oldreadonly=&readonly
  let &readonly=0
  let l:oldmodifiable=&modifiable
  let &modifiable=1
  if !exists("b:editHex") || !b:editHex
    " save old options
    let b:oldft=&ft
    let b:oldbin=&bin
    " set new options
    setlocal binary " make sure it overrides any textwidth, etc.
    silent :e " this will reload the file without trickeries
              "(DOS line endings will be shown entirely )
    let &ft="xxd"
    " set status
    let b:editHex=1
    " switch to hex editor
    %!xxd
  else
    " restore old options
    let &ft=b:oldft
    if !b:oldbin
      setlocal nobinary
    endif
    " set status
    let b:editHex=0
    " return to normal editing
    %!xxd -r
  endif
  " restore values for modified and read only state
  let &mod=l:modified
  let &readonly=l:oldreadonly
  let &modifiable=l:oldmodifiable
endfunction

" Status line
set statusline=
set statusline+=%#LineNr#
set statusline+=\ %f
set statusline+=%m%r%h%w
set statusline+=%=
set statusline+=%#CursorColumn#
set statusline+=\ %y
set statusline+=\ %{&fileencoding?&fileencoding:&encoding}
set statusline+=\[%{&fileformat}\]
set statusline+=\ %p%%
set statusline+=\ %l:%c

" tmux navigator
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

" Fuzzy search
nnoremap <leader>o :e **/

" History
nnoremap <silent> <leader>H :browse old<cr>

" Filetype
nnoremap <leader>F :setf<space>

" Netrw options
let g:netrw_altv = 1
let g:netrw_banner = 0
let g:netrw_browse_split = 4
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro rnu'
let g:netrw_fastbrowse = 2
let g:netrw_list_hide= '.*\.pyc$,\.DS_Store'
let g:netrw_liststyle = 3
let g:netrw_silent = 1
let g:netrw_sort_options = 'i'
let g:netrw_sort_sequence = '[\/]$'
let g:netrw_special_syntax = 1
let g:netrw_winsize = 25

" Ruby
augroup ruby_commands
  autocmd!
  autocmd FileType ruby nnoremap <buffer> <leader>sf :execute '!bin/rspec ' . shellescape(expand('%'))<cr>
  autocmd FileType ruby nnoremap <buffer> <leader>ss :execute '!bin/rspec ' . shellescape(expand('%') . ':' . line('.'))<cr>
  autocmd FileType ruby nnoremap <buffer> <leader>sa :execute '!bin/rspec'<cr>

  " Execute line in rails runner
  autocmd FileType ruby nnoremap <silent> <buffer> <leader>sr :silent execute '!tmux send-keys -t \! rails Space runner Space "' . shellescape(getline('.')) . '" Enter'<cr>:redraw!<cr>

  " Execute current spec in last pane
  autocmd FileType ruby nnoremap <silent> <buffer> <leader>si :silent execute '!tmux send-keys -t \! rspec Space ' . shellescape(expand('%') . ':' . line(".")) . ' Enter'<cr>:redraw!<cr>

  " Execute current spec file in last pane
  autocmd FileType ruby nnoremap <silent> <buffer> <leader>so :silent execute '!tmux send-keys -t \! rspec Space ' . shellescape(expand('%')) . ' Enter'<cr>:redraw!<cr>
augroup end

" Custom commands {{{ "
" Docker management
command! Dcup   !docker-compose up -d
command! Dcps   !docker-compose ps
command! Dcstop !docker-compose stop

" Open in Browser
command! -nargs=? -complete=file Canary     silent call OpenInBrowser('Google Chrome Canary', <f-args>)
command! -nargs=? -complete=file Chrome     silent call OpenInBrowser('Google Chrome', <f-args>)
command! -nargs=? -complete=file Firefox    silent call OpenInBrowser('Firefox', <f-args>)
command! -nargs=? -complete=file FirefoxDev silent call OpenInBrowser('FirefoxDeveloperEdition', <f-args>)
command! -nargs=? -complete=file Safari     silent call OpenInBrowser('Safari', <f-args>)
command! -nargs=? -complete=file SafariDev  silent call OpenInBrowser('Safari Technology Preview', <f-args>)

nnoremap <silent> <leader>< :Canary<cr>
nnoremap <silent> <leader>> :Canary :9001<cr>

function! OpenInBrowser(browser, ...)
  if a:0 == 0
    let l:route = 'http://localhost:3000'
  elseif match(a:1, '^:\d\+') != -1
    " :9001 should point to http://localhost:9001
    let l:route = 'http://localhost' . a:1
  else
    let l:route = a:1
  endif

  execute '!open "' . l:route . '" -a ' . shellescape(a:browser)
endfunction

" MacOS Quick-Look
command! -nargs=? -complete=file QuickLook silent call QuickLookFunction(<f-args>)
nnoremap <leader>¡ :QuickLook<cr>

function! QuickLookFunction(...)
  if a:0 == 0
    " If no files given, open current file
    let l:file = expand('%')
  else
    let l:file = a:1
  endif

  execute '!qlmanage -p ' . shellescape(l:file) . ' &> /dev/null'
endfunction
" }}} Custom commands "

" External Plugins {{{ "
" 'apprentice.vim' -- Vim color scheme.
" Author:       Romain Lafourcade (romainlafourcade@gmail.com)
" Description:  Essentially a streamlining and conversion to xterm colors of
"               'sorcerer' by Jeet Sukumaran (jeetsukumaran@gmailcom)
" Last Change:  2017 Oct 07

" MADE-UP NAME    HEX        RGB                   XTERM  ANSI
" ========================================================================
" almost black    #1c1c1c    rgb(28, 28, 28)       234    0
" darker grey     #262626    rgb(38, 38, 38)       235    background color
" dark grey       #303030    rgb(48, 48, 48)       236    8
" grey            #444444    rgb(68, 68, 68)       238    8
" medium grey     #585858    rgb(88, 88, 88)       240    8
" light grey      #6c6c6c    rgb(108, 108, 108)    242    7
" lighter grey    #bcbcbc    rgb(188, 188, 188)    250    foreground color
" white           #ffffff    rgb(255, 255, 255)    231    15
" purple          #5f5f87    rgb(95, 95, 135)      60     5
" light purple    #8787af    rgb(135, 135, 175)    103    13
" green           #5f875f    rgb(95, 135, 95)      65     2
" light green     #87af87    rgb(135, 175, 135)    108    10
" aqua            #5f8787    rgb(95, 135, 135)     66     6
" light aqua      #5fafaf    rgb(95, 175, 175)     73     14
" blue            #5f87af    rgb(95, 135, 175)     67     4
" light blue      #8fafd7    rgb(143, 175, 215)    110    12
" red             #af5f5f    rgb(175, 95, 95)      131    1
" orange          #ff8700    rgb(255, 135, 0)      208    9
" ocre            #87875f    rgb(135, 135, 95)     101    3
" yellow          #ffffaf    rgb(255, 255, 175)    229    11

hi clear

if exists("syntax_on")
  syntax reset
endif

let colors_name = "apprentice"

if ($TERM =~ '256' || &t_Co >= 256) || has("gui_running")
  hi Normal          ctermbg=235  ctermfg=250  guibg=#262626 guifg=#bcbcbc cterm=NONE           gui=NONE
  hi LineNr          ctermbg=234  ctermfg=242  guibg=#1c1c1c guifg=#6c6c6c cterm=NONE           gui=NONE
  hi FoldColumn      ctermbg=234  ctermfg=242  guibg=#1c1c1c guifg=#6c6c6c cterm=NONE           gui=NONE
  hi Folded          ctermbg=234  ctermfg=242  guibg=#1c1c1c guifg=#6c6c6c cterm=NONE           gui=NONE
  hi MatchParen      ctermbg=234  ctermfg=229  guibg=#1c1c1c guifg=#ffffaf cterm=NONE           gui=NONE
  hi signColumn      ctermbg=234  ctermfg=242  guibg=#1c1c1c guifg=#6c6c6c cterm=NONE           gui=NONE

  set background=dark

  hi Comment         ctermbg=NONE ctermfg=240  guibg=NONE    guifg=#585858 cterm=NONE           gui=NONE
  hi Conceal         ctermbg=NONE ctermfg=250  guibg=NONE    guifg=#bcbcbc cterm=NONE           gui=NONE
  hi Constant        ctermbg=NONE ctermfg=208  guibg=NONE    guifg=#ff8700 cterm=NONE           gui=NONE
  hi Error           ctermbg=NONE ctermfg=131  guibg=NONE    guifg=#af5f5f cterm=reverse        gui=reverse
  hi Identifier      ctermbg=NONE ctermfg=67   guibg=NONE    guifg=#5f87af cterm=NONE           gui=NONE
  hi Ignore          ctermbg=NONE ctermfg=NONE guibg=NONE    guifg=NONE    cterm=NONE           gui=NONE
  hi PreProc         ctermbg=NONE ctermfg=66   guibg=NONE    guifg=#5f8787 cterm=NONE           gui=NONE
  hi Special         ctermbg=NONE ctermfg=65   guibg=NONE    guifg=#5f875f cterm=NONE           gui=NONE
  hi Statement       ctermbg=NONE ctermfg=110  guibg=NONE    guifg=#8fafd7 cterm=NONE           gui=NONE
  hi String          ctermbg=NONE ctermfg=108  guibg=NONE    guifg=#87af87 cterm=NONE           gui=NONE
  hi Todo            ctermbg=NONE ctermfg=NONE guibg=NONE    guifg=NONE    cterm=reverse        gui=reverse
  hi Type            ctermbg=NONE ctermfg=103  guibg=NONE    guifg=#8787af cterm=NONE           gui=NONE
  hi Underlined      ctermbg=NONE ctermfg=66   guibg=NONE    guifg=#5f8787 cterm=underline      gui=underline

  hi NonText         ctermbg=NONE ctermfg=240  guibg=NONE    guifg=#585858 cterm=NONE           gui=NONE

  hi Pmenu           ctermbg=238  ctermfg=250  guibg=#444444 guifg=#bcbcbc cterm=NONE           gui=NONE
  hi PmenuSbar       ctermbg=240  ctermfg=NONE guibg=#585858 guifg=NONE    cterm=NONE           gui=NONE
  hi PmenuSel        ctermbg=66   ctermfg=235  guibg=#5f8787 guifg=#262626 cterm=NONE           gui=NONE
  hi PmenuThumb      ctermbg=66   ctermfg=66   guibg=#5f8787 guifg=#5f8787 cterm=NONE           gui=NONE

  hi ErrorMsg        ctermbg=131  ctermfg=235  guibg=#af5f5f guifg=#262626 cterm=NONE           gui=NONE
  hi ModeMsg         ctermbg=108  ctermfg=235  guibg=#87af87 guifg=#262626 cterm=NONE           gui=NONE
  hi MoreMsg         ctermbg=NONE ctermfg=66   guibg=NONE    guifg=#5f8787 cterm=NONE           gui=NONE
  hi Question        ctermbg=NONE ctermfg=108  guibg=NONE    guifg=#87af87 cterm=NONE           gui=NONE
  hi WarningMsg      ctermbg=NONE ctermfg=131  guibg=NONE    guifg=#af5f5f cterm=NONE           gui=NONE

  hi TabLine         ctermbg=238  ctermfg=101  guibg=#444444 guifg=#87875f cterm=NONE           gui=NONE
  hi TabLineFill     ctermbg=238  ctermfg=238  guibg=#444444 guifg=#444444 cterm=NONE           gui=NONE
  hi TabLineSel      ctermbg=101  ctermfg=235  guibg=#87875f guifg=#262626 cterm=NONE           gui=NONE

  hi Cursor          ctermbg=242  ctermfg=NONE guibg=#6c6c6c guifg=NONE    cterm=NONE           gui=NONE
  hi CursorColumn    ctermbg=236  ctermfg=NONE guibg=#303030 guifg=NONE    cterm=NONE           gui=NONE
  hi CursorLineNr    ctermbg=236  ctermfg=73   guibg=#303030 guifg=#5fafaf cterm=NONE           gui=NONE
  hi CursorLine      ctermbg=236  ctermfg=NONE guibg=#303030 guifg=NONE    cterm=NONE           gui=NONE

  hi helpLeadBlank   ctermbg=NONE ctermfg=NONE guibg=NONE    guifg=NONE    cterm=NONE           gui=NONE
  hi helpNormal      ctermbg=NONE ctermfg=NONE guibg=NONE    guifg=NONE    cterm=NONE           gui=NONE

  hi StatusLine      ctermbg=101  ctermfg=235  guibg=#87875f guifg=#262626 cterm=NONE           gui=NONE
  hi StatusLineNC    ctermbg=238  ctermfg=101  guibg=#444444 guifg=#87875f cterm=NONE           gui=NONE

  hi Visual          ctermbg=235  ctermfg=110  guibg=#262626 guifg=#8fafd7 cterm=reverse        gui=reverse
  hi VisualNOS       ctermbg=NONE ctermfg=NONE guibg=NONE    guifg=NONE    cterm=underline      gui=underline

  hi VertSplit       ctermbg=238  ctermfg=238  guibg=#444444 guifg=#444444 cterm=NONE           gui=NONE
  hi WildMenu        ctermbg=110  ctermfg=235  guibg=#8fafd7 guifg=#262626 cterm=NONE           gui=NONE

  hi Function        ctermbg=NONE ctermfg=229  guibg=NONE    guifg=#ffffaf cterm=NONE           gui=NONE
  hi SpecialKey      ctermbg=NONE ctermfg=240  guibg=NONE    guifg=#585858 cterm=NONE           gui=NONE
  hi Title           ctermbg=NONE ctermfg=231  guibg=NONE    guifg=#ffffff cterm=NONE           gui=NONE

  hi DiffAdd         ctermbg=235  ctermfg=108  guibg=#262626 guifg=#87af87 cterm=reverse        gui=reverse
  hi DiffChange      ctermbg=235  ctermfg=103  guibg=#262626 guifg=#8787af cterm=reverse        gui=reverse
  hi DiffDelete      ctermbg=235  ctermfg=131  guibg=#262626 guifg=#af5f5f cterm=reverse        gui=reverse
  hi DiffText        ctermbg=235  ctermfg=208  guibg=#262626 guifg=#ff8700 cterm=reverse        gui=reverse

  hi IncSearch       ctermbg=131  ctermfg=235  guibg=#af5f5f guifg=#262626 cterm=NONE           gui=NONE
  hi Search          ctermbg=229  ctermfg=235  guibg=#ffffaf guifg=#262626 cterm=NONE           gui=NONE

  hi Directory       ctermbg=NONE ctermfg=73   guibg=NONE    guifg=#5fafaf cterm=NONE           gui=NONE

  hi debugPC         ctermbg=67                guibg=#5f87af
  hi debugBreakpoint ctermbg=131               guibg=#af5f5f

  if has("gui_running")
    hi SpellBad      ctermbg=NONE ctermfg=131  guibg=NONE    guifg=NONE    cterm=undercurl      gui=undercurl guisp=#af5f5f
    hi SpellCap      ctermbg=NONE ctermfg=73   guibg=NONE    guifg=NONE    cterm=undercurl      gui=undercurl guisp=#5fafaf
    hi SpellLocal    ctermbg=NONE ctermfg=65   guibg=NONE    guifg=NONE    cterm=undercurl      gui=undercurl guisp=#5f875f
    hi SpellRare     ctermbg=NONE ctermfg=208  guibg=NONE    guifg=NONE    cterm=undercurl      gui=undercurl guisp=#ff8700
  else
    hi SpellBad      ctermbg=NONE ctermfg=131  guibg=NONE    guifg=#af5f5f cterm=undercurl      gui=undercurl guisp=NONE
    hi SpellCap      ctermbg=NONE ctermfg=73   guibg=NONE    guifg=#5fafaf cterm=undercurl      gui=undercurl guisp=NONE
    hi SpellLocal    ctermbg=NONE ctermfg=65   guibg=NONE    guifg=#5f875f cterm=undercurl      gui=undercurl guisp=NONE
    hi SpellRare     ctermbg=NONE ctermfg=208  guibg=NONE    guifg=#ff8700 cterm=undercurl      gui=undercurl guisp=NONE
  endif

  hi ColorColumn     ctermbg=234  ctermfg=NONE guibg=#1c1c1c guifg=NONE    cterm=NONE           gui=NONE
elseif &t_Co == 8 || $TERM !~# '^linux' || &t_Co == 16
  set t_Co=16

  hi Normal          ctermbg=NONE        ctermfg=white          cterm=NONE

  set background=dark

  hi Comment         ctermbg=NONE        ctermfg=gray        cterm=NONE
  hi Conceal         ctermbg=NONE        ctermfg=white       cterm=NONE
  hi Constant        ctermbg=NONE        ctermfg=red         cterm=NONE
  hi Function        ctermbg=NONE        ctermfg=yellow      cterm=NONE
  hi Identifier      ctermbg=NONE        ctermfg=darkblue    cterm=NONE
  hi PreProc         ctermbg=NONE        ctermfg=darkcyan    cterm=NONE
  hi Special         ctermbg=NONE        ctermfg=darkgreen   cterm=NONE
  hi Statement       ctermbg=NONE        ctermfg=blue        cterm=NONE
  hi String          ctermbg=NONE        ctermfg=green       cterm=NONE
  hi Todo            ctermbg=NONE        ctermfg=NONE        cterm=reverse
  hi Type            ctermbg=NONE        ctermfg=magenta     cterm=NONE

  hi Error           ctermbg=NONE        ctermfg=darkred     cterm=reverse
  hi Ignore          ctermbg=NONE        ctermfg=NONE        cterm=NONE
  hi Underlined      ctermbg=NONE        ctermfg=NONE        cterm=reverse

  hi LineNr          ctermbg=black       ctermfg=gray        cterm=NONE
  hi NonText         ctermbg=NONE        ctermfg=darkgray    cterm=NONE

  hi Pmenu           ctermbg=darkgray    ctermfg=white       cterm=NONE
  hi PmenuSbar       ctermbg=gray        ctermfg=NONE        cterm=NONE
  hi PmenuSel        ctermbg=darkcyan    ctermfg=black       cterm=NONE
  hi PmenuThumb      ctermbg=darkcyan    ctermfg=NONE        cterm=NONE

  hi ErrorMsg        ctermbg=darkred     ctermfg=black       cterm=NONE
  hi ModeMsg         ctermbg=darkgreen   ctermfg=black       cterm=NONE
  hi MoreMsg         ctermbg=NONE        ctermfg=darkcyan    cterm=NONE
  hi Question        ctermbg=NONE        ctermfg=green       cterm=NONE
  hi WarningMsg      ctermbg=NONE        ctermfg=darkred     cterm=NONE

  hi TabLine         ctermbg=darkgray    ctermfg=darkyellow  cterm=NONE
  hi TabLineFill     ctermbg=darkgray    ctermfg=black       cterm=NONE
  hi TabLineSel      ctermbg=darkyellow  ctermfg=black       cterm=NONE

  hi Cursor          ctermbg=NONE        ctermfg=NONE        cterm=NONE
  hi CursorColumn    ctermbg=darkgray    ctermfg=NONE        cterm=NONE
  hi CursorLineNr    ctermbg=black       ctermfg=cyan        cterm=NONE
  hi CursorLine      ctermbg=darkgray    ctermfg=NONE        cterm=NONE

  hi helpLeadBlank   ctermbg=NONE        ctermfg=NONE        cterm=NONE
  hi helpNormal      ctermbg=NONE        ctermfg=NONE        cterm=NONE

  hi StatusLine      ctermbg=darkyellow  ctermfg=black       cterm=NONE
  hi StatusLineNC    ctermbg=darkgray    ctermfg=darkyellow  cterm=NONE

  hi Visual          ctermbg=black       ctermfg=blue        cterm=reverse
  hi VisualNOS       ctermbg=black       ctermfg=white       cterm=reverse

  hi FoldColumn      ctermbg=black       ctermfg=darkgray    cterm=NONE
  hi Folded          ctermbg=black       ctermfg=darkgray    cterm=NONE

  hi VertSplit       ctermbg=darkgray    ctermfg=darkgray    cterm=NONE
  hi WildMenu        ctermbg=blue        ctermfg=black       cterm=NONE

  hi SpecialKey      ctermbg=NONE        ctermfg=darkgray    cterm=NONE
  hi Title           ctermbg=NONE        ctermfg=white       cterm=NONE

  hi DiffAdd         ctermbg=black       ctermfg=green       cterm=reverse
  hi DiffChange      ctermbg=black       ctermfg=magenta     cterm=reverse
  hi DiffDelete      ctermbg=black       ctermfg=darkred     cterm=reverse
  hi DiffText        ctermbg=black       ctermfg=red         cterm=reverse

  hi IncSearch       ctermbg=darkred     ctermfg=black       cterm=NONE
  hi Search          ctermbg=yellow      ctermfg=black       cterm=NONE

  hi Directory       ctermbg=NONE        ctermfg=cyan        cterm=NONE
  hi MatchParen      ctermbg=black       ctermfg=yellow      cterm=NONE

  hi SpellBad        ctermbg=NONE        ctermfg=darkred     cterm=undercurl
  hi SpellCap        ctermbg=NONE        ctermfg=darkyellow  cterm=undercurl
  hi SpellLocal      ctermbg=NONE        ctermfg=darkgreen   cterm=undercurl
  hi SpellRare       ctermbg=NONE        ctermfg=darkmagenta cterm=undercurl

  hi ColorColumn     ctermbg=black       ctermfg=NONE        cterm=NONE
  hi SignColumn      ctermbg=black       ctermfg=darkgray    cterm=NONE
endif

hi link Boolean                  Constant
hi link Character                Constant
hi link Conditional              Statement
hi link Debug                    Special
hi link Define                   PreProc
hi link Delimiter                Special
hi link Exception                Statement
hi link Float                    Number
hi link HelpCommand              Statement
hi link HelpExample              Statement
hi link Include                  PreProc
hi link Keyword                  Statement
hi link Label                    Statement
hi link Macro                    PreProc
hi link Number                   Constant
hi link Operator                 Statement
hi link PreCondit                PreProc
hi link Repeat                   Statement
hi link SpecialChar              Special
hi link SpecialComment           Special
hi link StorageClass             Type
hi link Structure                Type
hi link Tag                      Special
hi link Typedef                  Type

hi link htmlEndTag               htmlTagName
hi link htmlLink                 Function
hi link htmlSpecialTagName       htmlTagName
hi link htmlTag                  htmlTagName
hi link htmlBold                 Normal
hi link htmlItalic               Normal
hi link xmlTag                   Statement
hi link xmlTagName               Statement
hi link xmlEndTag                Statement

hi link markdownItalic           Preproc
hi link asciidocQuotedEmphasized Preproc

hi link diffBDiffer              WarningMsg
hi link diffCommon               WarningMsg
hi link diffDiffer               WarningMsg
hi link diffIdentical            WarningMsg
hi link diffIsA                  WarningMsg
hi link diffNoEOL                WarningMsg
hi link diffOnly                 WarningMsg
hi link diffRemoved              WarningMsg
hi link diffAdded                String

" Commentary {{{ "
" commentary.vim - Comment stuff out
" Maintainer:   Tim Pope <http://tpo.pe/>
" Version:      1.3
" GetLatestVimScripts: 3695 1 :AutoInstall: commentary.vim

if exists("g:loaded_commentary") || v:version < 700
  finish
endif
let g:loaded_commentary = 1

function! s:surroundings() abort
  return split(get(b:, 'commentary_format', substitute(substitute(
        \ &commentstring, '\S\zs%s',' %s','') ,'%s\ze\S', '%s ', '')), '%s', 1)
endfunction

function! s:strip_white_space(l,r,line) abort
  let [l, r] = [a:l, a:r]
  if l[-1:] ==# ' ' && stridx(a:line,l) == -1 && stridx(a:line,l[0:-2]) == 0
    let l = l[:-2]
  endif
  if r[0] ==# ' ' && a:line[-strlen(r):] != r && a:line[1-strlen(r):] == r[1:]
    let r = r[1:]
  endif
  return [l, r]
endfunction

function! s:go(...) abort
  if !a:0
    let &operatorfunc = matchstr(expand('<sfile>'), '[^. ]*$')
    return 'g@'
  elseif a:0 > 1
    let [lnum1, lnum2] = [a:1, a:2]
  else
    let [lnum1, lnum2] = [line("'["), line("']")]
  endif

  let [l, r] = s:surroundings()
  let uncomment = 2
  for lnum in range(lnum1,lnum2)
    let line = matchstr(getline(lnum),'\S.*\s\@<!')
    let [l, r] = s:strip_white_space(l,r,line)
    if len(line) && (stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
      let uncomment = 0
    endif
  endfor

  for lnum in range(lnum1,lnum2)
    let line = getline(lnum)
    if strlen(r) > 2 && l.r !~# '\\'
      let line = substitute(line,
            \'\M'.r[0:-2].'\zs\d\*\ze'.r[-1:-1].'\|'.l[0].'\zs\d\*\ze'.l[1:-1],
            \'\=substitute(submatch(0)+1-uncomment,"^0$\\|^-\\d*$","","")','g')
    endif
    if uncomment
      let line = substitute(line,'\S.*\s\@<!','\=submatch(0)[strlen(l):-strlen(r)-1]','')
    else
      let line = substitute(line,'^\%('.matchstr(getline(lnum1),'^\s*').'\|\s*\)\zs.*\S\@<=','\=l.submatch(0).r','')
    endif
    call setline(lnum,line)
  endfor
  let modelines = &modelines
  try
    set modelines=0
    silent doautocmd User CommentaryPost
  finally
    let &modelines = modelines
  endtry
  return ''
endfunction

function! s:textobject(inner) abort
  let [l, r] = s:surroundings()
  let lnums = [line('.')+1, line('.')-2]
  for [index, dir, bound, line] in [[0, -1, 1, ''], [1, 1, line('$'), '']]
    while lnums[index] != bound && line ==# '' || !(stridx(line,l) || line[strlen(line)-strlen(r) : -1] != r)
      let lnums[index] += dir
      let line = matchstr(getline(lnums[index]+dir),'\S.*\s\@<!')
      let [l, r] = s:strip_white_space(l,r,line)
    endwhile
  endfor
  while (a:inner || lnums[1] != line('$')) && empty(getline(lnums[0]))
    let lnums[0] += 1
  endwhile
  while a:inner && empty(getline(lnums[1]))
    let lnums[1] -= 1
  endwhile
  if lnums[0] <= lnums[1]
    execute 'normal! 'lnums[0].'GV'.lnums[1].'G'
  endif
endfunction

command! -range -bar Commentary call s:go(<line1>,<line2>)
xnoremap <silent> <Plug>Commentary     :Commentary<CR>
nnoremap <expr>   <Plug>Commentary     <SID>go()
nnoremap <expr>   <Plug>CommentaryLine <SID>go() . '_'
onoremap <silent> <Plug>Commentary        :<C-U>call <SID>textobject(0)<CR>
nnoremap <silent> <Plug>ChangeCommentary c:<C-U>call <SID>textobject(1)<CR>
nmap <silent> <Plug>CommentaryUndo :echoerr "Change your <Plug>CommentaryUndo map to <Plug>Commentary<Plug>Commentary"<CR>

if !hasmapto('<Plug>Commentary') || maparg('gc','n') ==# ''
  xmap gc  <Plug>Commentary
  nmap gc  <Plug>Commentary
  omap gc  <Plug>Commentary
  nmap gcc <Plug>CommentaryLine
  if maparg('c','n') ==# ''
    nmap cgc <Plug>ChangeCommentary
  endif
  nmap gcu <Plug>Commentary<Plug>Commentary
endif
" }}} Commentary "

let g:buftabline_show = 1
let g:buftabline_numbers = 2
let g:buftabline_indicators = 1
nmap <leader>1 <Plug>BufTabLine.Go(1)
nmap <leader>2 <Plug>BufTabLine.Go(2)
nmap <leader>3 <Plug>BufTabLine.Go(3)
nmap <leader>4 <Plug>BufTabLine.Go(4)
nmap <leader>5 <Plug>BufTabLine.Go(5)
nmap <leader>6 <Plug>BufTabLine.Go(6)
nmap <leader>7 <Plug>BufTabLine.Go(7)
nmap <leader>8 <Plug>BufTabLine.Go(8)
nmap <leader>9 <Plug>BufTabLine.Go(9)
nmap <leader>0 <Plug>BufTabLine.Go(10)
" Vim global plugin for rendering the buffer list in the tabline
" Licence:     The MIT License (MIT)
" Commit:      $Format:%H$
" {{{ Copyright (c) 2015 Aristotle Pagaltzis <pagaltzis@gmx.de>
"
" Permission is hereby granted, free of charge, to any person obtaining a copy
" of this software and associated documentation files (the "Software"), to deal
" in the Software without restriction, including without limitation the rights
" to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
" copies of the Software, and to permit persons to whom the Software is
" furnished to do so, subject to the following conditions:
"
" The above copyright notice and this permission notice shall be included in
" all copies or substantial portions of the Software.
"
" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
" AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
" OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
" THE SOFTWARE.
" }}}

if v:version < 700
  echoerr printf('Vim 7 is required for buftabline (this is only %d.%d)',v:version/100,v:version%100)
  finish
endif

scriptencoding utf-8

augroup BufTabLine
autocmd!

hi default link BufTabLineCurrent TabLineSel
hi default link BufTabLineActive  PmenuSel
hi default link BufTabLineHidden  TabLine
hi default link BufTabLineFill    TabLineFill

let g:buftabline_numbers    = get(g:, 'buftabline_numbers',    0)
let g:buftabline_indicators = get(g:, 'buftabline_indicators', 0)
let g:buftabline_separators = get(g:, 'buftabline_separators', 0)
let g:buftabline_show       = get(g:, 'buftabline_show',       2)
let g:buftabline_plug_max   = get(g:, 'buftabline_plug_max',  10)

function! Buftabline_user_buffers() " help buffers are always unlisted, but quickfix buffers are not
  return filter(range(1,bufnr('$')),'buflisted(v:val) && "quickfix" !=? getbufvar(v:val, "&buftype")')
endfunction

let s:dirsep = fnamemodify(getcwd(),':p')[-1:]
let s:centerbuf = winbufnr(0)
function! Buftabline_render()
  let show_num = g:buftabline_numbers == 1
  let show_ord = g:buftabline_numbers == 2
  let show_mod = g:buftabline_indicators
  let lpad     = g:buftabline_separators ? nr2char(0x23B8) : ' '

  let bufnums = Buftabline_user_buffers()
  let centerbuf = s:centerbuf " prevent tabline jumping around when non-user buffer current (e.g. help)

  " pick up data on all the buffers
  let tabs = []
  let path_tabs = []
  let tabs_per_tail = {}
  let currentbuf = winbufnr(0)
  let screen_num = 0
  for bufnum in bufnums
    let screen_num = show_num ? bufnum : show_ord ? screen_num + 1 : ''
    let tab = { 'num': bufnum }
    let tab.hilite = currentbuf == bufnum ? 'Current' : bufwinnr(bufnum) > 0 ? 'Active' : 'Hidden'
    if currentbuf == bufnum | let [centerbuf, s:centerbuf] = [bufnum, bufnum] | endif
    let bufpath = bufname(bufnum)
    if strlen(bufpath)
      let tab.path = fnamemodify(bufpath, ':p:~:.')
      let tab.sep = strridx(tab.path, s:dirsep, strlen(tab.path) - 2) " keep trailing dirsep
      let tab.label = tab.path[tab.sep + 1:]
      let pre = ( show_mod && getbufvar(bufnum, '&mod') ? '+' : '' ) . screen_num
      let tab.pre = strlen(pre) ? pre . ' ' : ''
      let tabs_per_tail[tab.label] = get(tabs_per_tail, tab.label, 0) + 1
      let path_tabs += [tab]
    elseif -1 < index(['nofile','acwrite'], getbufvar(bufnum, '&buftype')) " scratch buffer
      let tab.label = ( show_mod ? '!' . screen_num : screen_num ? screen_num . ' !' : '!' )
    else " unnamed file
      let tab.label = ( show_mod && getbufvar(bufnum, '&mod') ? '+' : '' )
      \             . ( screen_num ? screen_num : '*' )
    endif
    let tabs += [tab]
  endfor

  " disambiguate same-basename files by adding trailing path segments
  while len(filter(tabs_per_tail, 'v:val > 1'))
    let [ambiguous, tabs_per_tail] = [tabs_per_tail, {}]
    for tab in path_tabs
      if -1 < tab.sep && has_key(ambiguous, tab.label)
        let tab.sep = strridx(tab.path, s:dirsep, tab.sep - 1)
        let tab.label = tab.path[tab.sep + 1:]
      endif
      let tabs_per_tail[tab.label] = get(tabs_per_tail, tab.label, 0) + 1
    endfor
  endwhile

  " now keep the current buffer center-screen as much as possible:

  " 1. setup
  let lft = { 'lasttab':  0, 'cut':  '.', 'indicator': '<', 'width': 0, 'half': &columns / 2 }
  let rgt = { 'lasttab': -1, 'cut': '.$', 'indicator': '>', 'width': 0, 'half': &columns - lft.half }

  " 2. sum the string lengths for the left and right halves
  let currentside = lft
  for tab in tabs
    let tab.label = lpad . get(tab, 'pre', '') . tab.label . ' '
    let tab.width = strwidth(strtrans(tab.label))
    if centerbuf == tab.num
      let halfwidth = tab.width / 2
      let lft.width += halfwidth
      let rgt.width += tab.width - halfwidth
      let currentside = rgt
      continue
    endif
    let currentside.width += tab.width
  endfor
  if currentside is lft " centered buffer not seen?
    " then blame any overflow on the right side, to protect the left
    let [lft.width, rgt.width] = [0, lft.width]
  endif

  " 3. toss away tabs and pieces until all fits:
  if ( lft.width + rgt.width ) > &columns
    let oversized
    \ = lft.width < lft.half ? [ [ rgt, &columns - lft.width ] ]
    \ : rgt.width < rgt.half ? [ [ lft, &columns - rgt.width ] ]
    \ :                        [ [ lft, lft.half ], [ rgt, rgt.half ] ]
    for [side, budget] in oversized
      let delta = side.width - budget
      " toss entire tabs to close the distance
      while delta >= tabs[side.lasttab].width
        let delta -= remove(tabs, side.lasttab).width
      endwhile
      " then snip at the last one to make it fit
      let endtab = tabs[side.lasttab]
      while delta > ( endtab.width - strwidth(strtrans(endtab.label)) )
        let endtab.label = substitute(endtab.label, side.cut, '', '')
      endwhile
      let endtab.label = substitute(endtab.label, side.cut, side.indicator, '')
    endfor
  endif

  if len(tabs) | let tabs[0].label = substitute(tabs[0].label, lpad, ' ', '') | endif

  let swallowclicks = '%'.(1 + tabpagenr('$')).'X'
  return swallowclicks . join(map(tabs,'printf("%%#BufTabLine%s#%s",v:val.hilite,strtrans(v:val.label))'),'') . '%#BufTabLineFill#'
endfunction

function! Buftabline_update(zombie)
  set tabline=
  if tabpagenr('$') > 1 | set guioptions+=e showtabline=2 | return | endif
  set guioptions-=e
  if 0 == g:buftabline_show
    set showtabline=1
    return
  elseif 1 == g:buftabline_show
    " account for BufDelete triggering before buffer is actually deleted
    let bufnums = filter(Buftabline_user_buffers(), 'v:val != a:zombie')
    let &g:showtabline = 1 + ( len(bufnums) > 1 )
  elseif 2 == g:buftabline_show
    set showtabline=2
  endif
  set tabline=%!Buftabline_render()
endfunction

autocmd VimEnter  * call Buftabline_update(0)
autocmd TabEnter  * call Buftabline_update(0)
autocmd BufAdd    * call Buftabline_update(0)
autocmd BufDelete * call Buftabline_update(str2nr(expand('<abuf>')))

for s:n in range(1, g:buftabline_plug_max)
    execute printf("noremap <silent> <Plug>BufTabLine.Go(%d) :exe 'b'.get(Buftabline_user_buffers(),%d,'')<cr>", s:n, s:n - 1)
endfor
unlet s:n

if v:version < 703
  function s:transpile()
    let [ savelist, &list ] = [ &list, 0 ]
    redir => src
      silent function Buftabline_render
    redir END
    let &list = savelist
    let src = substitute(src, '\n\zs[0-9 ]*', '', 'g')
    let src = substitute(src, 'strwidth(strtrans(\([^)]\+\)))', 'strlen(substitute(\1, ''\p\|\(.\)'', ''x\1'', ''g''))', 'g')
    return src
  endfunction
  exe "delfunction Buftabline_render\n" . s:transpile()
  delfunction s:transpile
endif
" }}} External Plugins "
