## Main
# main
snippet main
	int main(int argc, char *argv[]) {
		${0}
	}

# ##
# ## Preprocessor
# # #include <...>
# snippet inc
# 	#include <${1:stdio}.h>
# 	$0
# # #include "..."
# # snippet Inc
# # 	#include "${1:`vim_snippets#Filename("$1.h")`}"
# # 	$0
# # ifndef...define...endif
# snippet ndef
# 	#ifndef $1
# 	#define ${1:SYMBOL} ${2:value}
# 	#endif /* ifndef $1 */
# # define
# snippet def
# 	#define
# # ifdef...endif
# snippet ifdef
# 	#ifdef ${1:FOO}
# 		${2:#define }
# 	#endif
# # if
# snippet #if
# 	#if ${1:FOO}
# 		${0:${VISUAL}}
# 	#endif
# # Disable C++ name mangling in C headers
# snippet nocxx
# 	#ifdef __cplusplus
# 	extern "C" {
# 	#endif
#
# 	${0}
#
# 	#ifdef __cplusplus
# 	} /* extern "C" */
# 	#endif
# ##
# ## Control Statements
# # if
# snippet if
# 	if (${1:true}) {
# 		${0:${VISUAL}}
# 	}
# snippet ife
# 	if (${1:true}) {
# 		${2:${VISUAL}}
# 	} else {
# 		${0}
# 	}
# # else
# snippet el
# 	else {
# 		${0:${VISUAL}}
# 	}
# # else if
# snippet elif
# 	else if (${1:true}) {
# 		${0:${VISUAL}}
# 	}
# # ifi
# snippet ifi
# 	if (${1:true}) ${0};
# # ternary
# snippet t Ternary: `condition ? true : false`
# 	$1 ? $2 : $0
# # switch
# snippet switch
# 	switch (${1:/* variable */}) {
# 		case ${2:/* variable case */}:
# 			${3}
# 			${4:break;}${5}
# 		default:
# 			${6}
# 	}
# # case
# snippet case
# 	case ${1:/* variable case */}:
# 		${2}
# 		${3:break;}
# snippet ret
# 	return ${0};
# snippet ex
# 	exit($0);
# ##
# ## Loops
# # for
# snippet for
# 	for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) {
# 		${4}
# 	}
# # while
# snippet wh
# 	while (${1:1}) {
# 		${0:${VISUAL}}
# 	}
# snippet wht
# 	while (true) {
# 		${0:${VISUAL}}
# 	}
# # do... while
# snippet do
# 	do {
# 		${0:${VISUAL}}
# 	} while ($1);
# ##
# ## Functions
# # function definition
# snippet fun
# 	${1:void} ${2:function_name}(${3}) {
# 		${4}
# 	}
# # function declaration
# snippet fund
# 	${1:void} ${2:function_name}(${3});
# ##
# ## Types
# # typedef
# snippet td
# 	typedef ${1:int} ${2:MyCustomType};
# # struct
# snippet st
# 	/*! \struct $1
# 	 *  \brief ${3:Brief struct description}
# 	 *
# 	 *  ${4:Detailed description}
# 	 */
# 	struct ${1:`vim_snippets#Filename('$1_t', 'name')`} {
# 		${2:Data} /*!< ${4:Description} */
# 	}${5: /* optional variable list */};
# # typedef struct
# snippet tds
# 	/*! \struct $2
# 	 *  \brief ${5:Brief struct description}
# 	 *
# 	 *  ${6:Detailed description}
# 	 */
# 	typedef struct ${2:_$1 }{
# 		m_${3:Data} /*!< ${4:Description} */
# 	} ${1:`vim_snippets#Filename('$1_t', 'name')`};
#
# snippet enum
# 	/*! \enum $1
# 	 *
# 	 *  ${2:Detailed description}
# 	 */
# 	enum ${1:name} { ${0} };
# # typedef enum
# snippet tde
# 	/*! \enum $2
# 	 *
# 	 *  ${4:Detailed description}
# 	 */
# 	typedef enum {
# 		${1:Data} /*!< ${3:Description} */
# 	} ${2:foo};
# ##
# ## Input/Output
# # printf
# snippet pr
# 	printf("${1:%s}\n"${2});
# # fprintf (again, this isn't as nice as TextMate's version, but it works)
# snippet fpr
# 	fprintf(${1:stderr}, "${2:%s}\n"${3});
# snippet prd
# 	printf("${1:} = %d\n", $1);
# snippet prf
# 	printf("${1:} = %f\n", $1);
# snippet prx
# 	printf("${1:} = %${2}\n", $1);
# snippet warn
# 	warn("${1:%s}"$0);
# snippet warnx
# 	warnx("${1:%s}"$0);
# snippet err
# 	err(${1:1}, "${2:%s}"$0);
# snippet errx
# 	errx(${1:1}, "${2:%s}"$0);
# # getopt
# snippet getopt
# 	int choice;
# 	while (1)
# 	{
# 		static struct option long_options[] =
# 		{
# 			/* Use flags like so:
# 			{"verbose",	no_argument,	&verbose_flag, 'V'}*/
# 			/* Argument styles: no_argument, required_argument, optional_argument */
# 			{"version", no_argument,	0,	'v'},
# 			{"help",	no_argument,	0,	'h'},
# 			${1}
# 			{0,0,0,0}
# 		};
#
# 		int option_index = 0;
#
# 		/* Argument parameters:
# 			no_argument: " "
# 			required_argument: ":"
# 			optional_argument: "::" */
#
# 		choice = getopt_long( argc, argv, "vh",
# 					long_options, &option_index);
#
# 		if (choice == -1)
# 			break;
#
# 		switch( choice )
# 		{
# 			case 'v':
# 				${2}
# 				break;
#
# 			case 'h':
# 				${3}
# 				break;
#
# 			case '?':
# 				/* getopt_long will have already printed an error */
# 				break;
#
# 			default:
# 				/* Not sure how to get here... */
# 				return EXIT_FAILURE;
# 		}
# 	}
#
# 	/* Deal with non-option arguments here */
# 	if ( optind < argc )
# 	{
# 		while ( optind < argc )
# 		{
# 			${0}
# 		}
# 	}
#
# ## Assertions
# snippet asr
# 	assert($1);
#
# snippet anl
# 	assert(${1:ptr} != NULL);
#
# ## Dynamic Allocation
# snippet mlc
# 	${1:ptr} = (${2:type}*) malloc(sizeof($2));
#
# snippet clc
# 	${1:ptr} = (${2:type}*) calloc(${3:size}, sizeof($2));
#
# snippet rlc
# 	${1:ptr} = realloc($1, ${2:size} * sizeof(${3:type}));
#
# snippet mlcd
# 	${1:type} ${2:ptr} = ($1*) malloc(sizeof($1));
#
# snippet clcd
# 	${1:type} ${2:ptr} = ($1*) calloc(${3:size}, sizeof($1));
#
# snippet fre
# 	free(${1:ptr});
#
# ## Miscellaneous
# # This is kind of convenient
# snippet .
# 	[${1}]
