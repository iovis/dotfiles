# Functions
snippet let "let variable declaration with type inference" b
	let ${1} = ${2};
snippet letm "let mut variable declaration with type inference" b
	let mut ${1} = ${2};
snippet fmt "format!" b
	format!("${1}{${2}}", ${3});
snippet d "dbg! debugging macro" b
	dbg!(${0:${VISUAL}})
snippet d; "dbg! debugging macro statement" b
	dbg!(&${1});
	${0}
# Modules
snippet mod b
	mod ${1:mod_name} {
		${0}
	}
# Testing
snippet as "assert!" b
	assert!(${1:predicate});
snippet ase "assert_eq!" b
	assert_eq!(${1:expected}, ${2:actual});
snippet test "Unit test function" b
	#[test]
	fn ${1:function_name}() {
		${0}
	}
snippet modtest "Test module" b
	#[cfg(test)]
	mod tests {
		use super::${1:*};

		test${0}
	}
snippet ig "#[ignore]" b
	#[ignore]
# Attributes
snippet allow "allow lint attribute" b
	#[allow(${1:unused_variables})]
snippet cfg "cfg attribute" b
	#[cfg(${1:target_os = "linux"})]
snippet feat "feature attribute" b
	#![feature(${1:plugin})]
snippet der "#[derive(..)]" b
	#[derive(${1:Debug}$2)]
snippet attr "#[..]" b
	#[${1:inline}]
# Control structures
snippet if
	if ${1} {
		${0:${VISUAL}}
	}
snippet ife "if / else"
	if ${1} {
		${2:${VISUAL}}
	} else {
		${0}
	}
snippet ifl "if let (...)"
	if let ${1} = $2 {
		${0:${VISUAL}}
	}
snippet el "else"
	else {
		${0:${VISUAL}}
	}
snippet eli "else if"
	else if ${1} {
		${0:${VISUAL}}
	}
snippet mat "match pattern"
	match ${1} {
		${2} => ${3}
	}
snippet case "Case clause of pattern match" b
	${1:_} => ${2:expression}
snippet loop "loop {}" b
	loop {
		${0:${VISUAL}}
	}
snippet wh "while loop" b
	while ${1:condition} {
		${0:${VISUAL}}
	}
snippet whl "while let (...)" b
	while let ${1:Some($2)} = $3 {
		${0:${VISUAL}}
	}
snippet for "for ... in ... loop" b
	for ${1:i} in ${2} {
		${0}
	}
# Struct
snippet impl "Struct/Trait implementation" b
	impl ${1:Type/Trait}${2: for $3} {
		${0}
	}
snippet ty "Type alias" b
	type ${1:NewName} = $2;
snippet enum "enum definition" b
	enum ${1:Name} {
		${2},
	}
snippet penum "pub enum definition" b
	pub enum ${1:Name} {
		${2},
	}
# Traits
snippet trait "Trait definition" b
	trait ${1:Name} {
		${0}
	}
snippet drop "Drop trait implementation (destructor)" b
	impl Drop for $1 {
		fn drop(&mut self) {
			${0}
		}
	}
snippet unim "unimplemented!()"
	unimplemented!()
